# 理解所有权

所有权是 Rust 最独特的功能，其对 Rust 语言的其他部分有着深刻的影响。所有权保证了 Rust 可以在不需要垃圾回收器的情况下保证内存安全，所以理解所有权是如何工作的就十分重要。在这一章，我们会讨论所有权以及几个相关特性：借用、切片，以及 Rust 如何在内存中排列数据。

# 什么是所有权？

所有权是一种保证 Rust 程序 **安全** 的机制。要理解所有权，我们需要先理解什么会导致 Rust
程序不安全。

## 安全即没有未定义行为

让我们先举一个例子。下面的程序是可以安全执行的：

```rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    let x = true;
    read(x);
}
```

要让这个程序变得不安全，我们可以把 `read` 调用挪到 `x` 的定义之上：

```rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    read(x); // oh no! x isn't defined!
    let x = true;
}
```

> 这段代码无法通过编译

第二个程序是不安全的，因为 `read(x)` 期望 `x` 有一个 `bool` 类型的值，但是此时 `x` 还没有值。

如果一个解释器执行类似上述的代码，在 `x` 定义之前试图读取就会引发一个异常，比如在 Python 中是 `NameError`，在 JavaScript 中是 `ReferenceError`。但是想引发异常是有代价的，每次程序想要读取一个变量，解释器就得检查这个变量是不是已经定义了。

Rust 的目标是编译出一个高效的二进制程序，能尽可能少的做运行时检查。因此 Rust 不会在 *运行时* 检查一个变量在使用前有没有被定义。相反，Rust 在 *编译时* 检查。如果你尝试编译这段不安全的程序，你会看到如下报错：

```text
error[E0425]: cannot find value `x` in this scope
 --> src/main.rs:8:10
  |
8 |     read(x); // oh no! x isn't defined!
  |          ^ not found in this scope
```

大概你也能感觉到，Rust 保证一个变量在使用前是被定义的，这是一件好事。但是为何要如此呢？为了论证这一点，我们需要知道：**如果 Rust 允许这样一个不安全的程序编译，会发生什么？**

让我们先来看一下一个安全的程序是如何编译并执行的。在一台使用 x86 架构处理器的计算机上，Rust 编译上述安全程序的 `main` 函数并生成了如下汇编代码（[点击查看完整代码](https://rust.godbolt.org/z/xnT1fzsqv)）：

```x86asm
main:
    ; ...
    mov     edi, 1
    call    read
    ; ...
```

> 注意：如果你不熟悉汇编代码，没有关系。这一部分会涉及到几个汇编代码的例子，但只是为了向你展示 Rust 底层是如何工作的。汇编不是学习 Rust 的必需工具。

这段汇编代码做了如下几件事：

- 将数字 1，也就是 `true`，移动到一个叫 `edi` 的寄存器（一种汇编语言的变量）中。
- 调用 `call` 函数，同时期望能在 `edi` 这个寄存器中找到参数 `y` 的值。

如果那段不安全的代码被允许编译，那么生成的汇编代码可能会像下面这样：

```x86asm
main:
    ; ...
    call    read
    mov     edi, 1    ; mov is after call
    ; ...
```

这个程序是不安全的，因为 `read` 希望 `edi` 中会有一个布尔值，要么是 `0` 要么是 `1`，但是此时 `edi` 里可能是任意值：`2`，`100`，`0x1337BEEF` 等等。当 `read` 想使用参数 `y` 的时候，就会立刻触发 **未定义行为**！

Rust 没有规定当你运行 `if y { .. }` 但 `y` 既不是 `true` 也不是 `false` 的时候会发生什么。这种行为，或者说执行了这段代码之后会发生什么，是 *未定义的*。什么都可能发生，比如：

- 程序执行得好好的，没有崩溃，没人发现任何问题。
- 程序立刻因为[存储器区段错误](https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4)或其他操作系统错误而崩溃。
- 程序没有崩溃，直到某一天一个别有用心的人借此找到了一个漏洞，然后删掉了你的生产数据库，重写了你的备份，还偷走了你的午饭钱。







