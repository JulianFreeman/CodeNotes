# 理解所有权

所有权是 Rust 最独特的功能，其对 Rust 语言的其他部分有着深刻的影响。所有权保证了 Rust 可以在不需要垃圾回收器的情况下保证内存安全，所以理解所有权是如何工作的就十分重要。在这一章，我们会讨论所有权以及几个相关特性：借用、切片，以及 Rust 如何在内存中排列数据。

# 什么是所有权？

所有权是一种保证 Rust 程序 **安全** 的机制。要理解所有权，我们需要先理解什么会导致 Rust
程序不安全。

## 安全即没有未定义行为

让我们先举一个例子。下面的程序是可以安全执行的：

```rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    let x = true;
    read(x);
}
```

要让这个程序变得不安全，我们可以把 `read` 调用挪到 `x` 的定义之上：

```rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    read(x); // oh no! x isn't defined!
    let x = true;
}
```

> 这段代码无法通过编译

第二个程序是不安全的，因为 `read(x)` 期望 `x` 有一个 `bool` 类型的值，但是此时 `x` 还没有值。

如果一个解释器执行类似上述的代码，在 `x` 定义之前试图读取就会引发一个异常，比如在 Python 中是 `NameError`，在 JavaScript 中是 `ReferenceError`。但是想引发异常是有代价的，每次程序想要读取一个变量，解释器就得检查这个变量是不是已经定义了。

Rust 的目标是编译出一个高效的二进制程序，能尽可能少的做运行时检查。因此 Rust 不会在 *运行时* 检查一个变量在使用前有没有被定义。相反，Rust 在 *编译时* 检查。如果你尝试编译这段不安全的程序，你会看到如下报错：

```text
error[E0425]: cannot find value `x` in this scope
 --> src/main.rs:8:10
  |
8 |     read(x); // oh no! x isn't defined!
  |          ^ not found in this scope
```

大概你也能感觉到，Rust 保证一个变量在使用前是被定义的，这是一件好事。但是为何要如此呢？为了论证这一点，我们需要知道：**如果 Rust 允许这样一个不安全的程序编译，会发生什么？**

让我们先来看一下一个安全的程序是如何编译并执行的。在一台使用 x86 架构处理器的计算机上，Rust 编译上述安全程序的 `main` 函数并生成了如下汇编代码（[点击查看完整代码](https://rust.godbolt.org/z/xnT1fzsqv)）：

```assembly
main:
    ; ...
    mov     edi, 1
    call    read
    ; ...
```

> 注意：如果你不熟悉汇编代码，没有关系。这一部分会涉及到几个汇编代码的例子，但只是为了向你展示 Rust 底层是如何工作的。汇编不是学习 Rust 的必需工具。

这段汇编代码做了如下几件事：

- 将数字 1，也就是 `true`，移动到一个叫 `edi` 的寄存器（一种汇编语言的变量）中。
- 调用 `call` 函数，同时期望能在 `edi` 这个寄存器中找到参数 `y` 的值。

如果那段不安全的代码被允许编译，那么生成的汇编代码可能会像下面这样：

```assembly
main:
    ; ...
    call    read
    mov     edi, 1    ; mov is after call
    ; ...
```

这个程序是不安全的，因为 `read` 希望 `edi` 中会有一个布尔值，要么是 `0` 要么是 `1`，但是此时 `edi` 里可能是任意值：`2`，`100`，`0x1337BEEF` 等等。当 `read` 想使用参数 `y` 的时候，就会立刻触发 **未定义行为**！

Rust 没有规定当你运行 `if y { .. }` 但 `y` 既不是 `true` 也不是 `false` 的时候会发生什么。这种行为，或者说执行了这段代码之后会发生什么，是 *未定义的*。什么都可能发生，比如：

- 程序执行得好好的，没有崩溃，没人发现任何问题。
- 程序立刻因为[存储器区段错误](https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4)或其他操作系统错误而崩溃。
- 程序没有崩溃，直到某一天一个别有用心的人借此找到了一个漏洞，然后删掉了你的生产数据库，重写了你的备份，还偷走了你的午饭钱。

**Rust 一个最基本的目标是保证你的程序永远没有未定义行为。** 这就是“安全”的含义。未定义行为对于能直接操作内存的低级语言来说特别危险。在[报道出来的有关低级系统的安全漏洞](https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/)中，大概有 70% 是由内存损坏引起的，而内存损坏就是其中一种未定义行为。

Rust 的第二个目标就是在 *编译时* 就阻断未定义行为，而不是在 *运行时*。这样做有两个原因：

1. 在编译时发现 bug，意味着在发布后能避免这些 bug，这样提高了软件的稳定性。
2. 在编译时发现 bug，意味着能少一些运行时检查，这样提高了软件的性能。

Rust 不能防止所有的 bug。如果一个程序暴露了一个公有的无需授权的“删除生产数据库”端点，那么别有用心的人就不需要尝试什么 `if` 语句来删除数据库了。但是 Rust 的保护机制相比于其他少有保护机制的语言，还是能让程序更安全些的。[谷歌的安卓团队](https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html)是这么说的。

## 所有权，一种内存安全机制

既然安全指的是没有未定义行为，而所有权是有关安全的，那我们就需要理解所有权如何防止未定义行为的。Rust 参考手册中维护了一个“[被认为是未定义行为](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)”的长长的列表。但目前为止，我们只需要关注其中一个方面：内存操作。

内存是程序执行时用来存储数据的地方。我们可以用很多种方式来思考内存：

- 如果你不熟悉系统编程，你可能会在一个较高的抽象上把内存理解为电脑里的内存条，或者一个我加载数据越多就会变得越少的东西。
- 如果你熟悉系统编程，你可能会在一个较低的抽象上把内存理解为一个字节数组，或者我调用 `malloc` 时拿回来的指针。

上述两种内存模型都是合理的，但是用它们来思考 Rust 的运作模式不是很有用。较高的抽象，太高了，因为你还是需要理解指针的概念的。较低的抽象，太低了，毕竟 Rust 不允许你把内存解析为一串字节数组。

Rust 用一种特别的方式来思考内存。所有权就是在这种思考方式下，用来安全使用内存的机制。本章剩余的部分会解释 Rust 的内存模型。

## 栈中的变量

下面是一段代码，定义了一个数字 `n`，然后用 `n` 调用函数 `plus_one`。

```rust
fn main() {
    let n = 5; //L1
    let y = plus_one(n); //L3
    println!("The value of y is: {y}");
}

fn plus_one(x: i32) -> i32 {
    //L2
    x + 1
}
```

变量存在于 **栈帧** 中。栈帧是一种在单一作用域（比如函数）下从变量到值得映射。举例如下：

- L1 位置下，`main` 的栈帧中保存了 `n = 5`。
- L2 位置下，`plus_one` 的栈帧中保存了 `x = 5`。
- L3 位置下，`main` 的栈帧中保存了 `n = 5; y = 6`。

栈帧被放在一个当前调用函数的 **栈** 中。比如说，在 L2 位置，`main` 的栈帧在 `plus_one` 的栈帧之上。当函数返回时，Rust 就会释放这个函数的栈帧。这样一个栈帧的序列被称为一个栈，因为最后加入的帧是最先被释放的。

> 注意：这个内存模型并不完全符合 Rust 的工作模式。就像我们之前在汇编代码那里看到的，Rust 编译器也可能会把 `n` 或者 
`x` 放入一个寄存器而不是栈帧。但这些区别都是具体的实现细节了，不影响我们理解 Rust 的安全机制。所以我们还是只关注栈帧中的变量这种简单的情况。

当一个表达式要读取一个变量的时候，程序就会从栈帧中把这个变量的值拷贝一份。比如说我们运行这段程序：

```rust
let a = 5;
let mut b = a; // b = 5
b += 1; // a = 5; b = 6
```

`a` 的值被拷贝了一份给 `b`，在 `b` 自增之后，`a` 依然保持不变。

## 堆上的 Box

然而，拷贝数据会占用大量内存。比如说，下面是一个稍微修改过的程序，这个程序拷贝了一个有一百万个值的数组。

```rust
let a = [0; 1_000_000];
let b = a;
```

可以看到，把 `a` 拷贝到 `b` 之后，`main` 的栈帧上保存了两百万个值。

如果想转移数据但又不想拷贝，Rust 使用 **指针** 来达到这一点。指针是一个描述内存中某个位置的值。那个被指针指向的值就被叫做被指者。一个常用的获取指针的方式是在 **堆** 上分配内存。堆是内存中一块特别的区域，在这里数据可以不限期地保留。堆上的数据不会跟某个特定的栈帧绑定。Rust 提供了一个叫 `Box` 的结构来把数据放在堆上。比如说，我们可以把那有一百万个值的数组放进 `Box::new` 中：

```rust
let a = Box::new([0; 1_000_000]); // L1
let b = a; // L2
```

现在可以看到，此时只有一个数组存在了。在 L1，`a` 的值是一个指针，指向了堆上的一个数组。语句 `let b = a` 把 `a` 保存的指针拷贝给了 `b`，但是被指向的数据并没有拷贝。注意，现在 `a` 实际是被转移了，我们稍后会解释这是什么意思。

## Rust 不允许手动管理内存

内存管理是一个分配内存和释放内存的过程。换句话说，内存管理就是寻找那些不再使用的内存并把它们返还。栈帧是由 Rust 自动管理的。当一个函数被调用的时候，Rust 会分配一块栈帧给这个函数，当这个调用结束的时候，Rust 会释放这个栈帧。

我们在前面看到，堆上的数据是我们调用 `Box::new(..)` 的时候分配的，那什么时候释放呢？假如说 Rust 有一个叫 `free()` 的函数用来释放堆上的内存，想象一下 Rust 让程序员来决定他们何时要调用 `free`。这种手动的内存管理很容易就会导致 bug。比如说，我们可能会尝试读取一个指向已经被释放的内存的指针：

```rust
let b = Box::new([0; 100]); // L1
free(b); // L2
assert!(b[0] == 0); // L3
```

> 上述代码不可编译

> 注意：你可能会想，我们怎么执行一段 Rust 不让编译的程序呢？我们使用一些[特殊的工具](https://github.com/cognitive-engineering-lab/aquascope)来模拟 Rust 的借用检查器被禁用的情况，当然，为了教学目的。这样我们就可以回答一些假设的问题，比如：假设 Rust 可以让不安全的程序通过编译？

这里，我们在堆上分配了一个数组，然后我们调用了 `free(b)`，这使得 `b` 的堆内存被释放了。因此 `b` 的值就变成一个指向非法内存的指针了。目前未知还没有任何未定义行为发生！在 L2 的位置，程序尚且安全。保留一个非法指针并不是啥大问题。

未定义行为发生在当我们想通过 `b[0]` 使用这个指针的时候。这个行为试图获取非法内存，可能就会导致程序崩溃，或者可能更糟，程序没有崩溃，而是返回了任意数据。因此这个程序是 **不安全** 的。

Rust 不允许程序手动释放内存。这种政策就避免了上述未定义行为的发生。

## Box 的所有者负责释放内存











